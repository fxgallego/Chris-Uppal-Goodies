<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
        "http://www.w3.org/TR/REC-html40/loose.dtd">

<!--	Copyright (c) Chris Uppal, 2003-2005	-->

<HTML>
<HEAD>
<TITLE>JNIPort for Dolphin Smalltalk</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Author" CONTENT="Chris Uppal">
<META name="keywords" content="Smalltalk, Dolphin Smalltalk, Java and Smalltalk">
</HEAD>

<BODY>
<TABLE cellpadding=5 cellspacing=0 width="100%">
<TBODY>
<TR align=center valign=middle bgcolor="#F0FFFF">
        <TD>
		<TABLE border=5 cellspacing=3 cellpadding=3 bgcolor="white"><TBODY><TR>
			<TD align="center" valign="middle" bgcolor="aqua">
				<H2><A href="http://www.metagnostic.org/">Metagnostic<BR>home</A></H2>
			</TD>
		</TR></TBODY></TABLE>
	</TD>
        <TD align="center" valign="middle">
		<H1>JNIPort for Dolphin Smalltalk</H1>
	</TD>
</TR>
<TR>
	<TD width=150 valign=top bgcolor="#F0FFFF">
		<P><A href="overview.html">Overview</A></P>
		<P><A href="index.html">Contents</A></P>
		<P><A href="players.html">Players</A></P>
		<P><A href="layers.html">Layers</A></P>
		<P><A href="examples.html">Examples</A></P>
		<P><A href="setup.html">Configuration</A></P>
		<P><A href="infaq.html">InFAQ</A></P>
		<P><A href="changes.html">Changes</A></P>
		<P><A href="../TermsOfUse.html">Licence</A></P>
		<hr>
		<P>Back to <A href="../index.html">Goodies</A></P>
	</TD>
<TD valign=top>
<!--	real-text-starts-here	-->
<H1>Ghost Classes</H1>
<P>
JNIPort includes the <A href="wrapper-wizard.html">Wrapper Wizard</A> which uses Java's
introspective facilities (such as they are) to generate wrapper methods for Java members.
The <DFN>ghost class</DFN> concept takes this one step further. Ghost classes are (relatively)
light-weight classes that are generated on demand, and which are discarded when the Java
runtime shuts down.  They are populated with <DFN>ghost methods</DFN>, which are essentially
the same as the wrapper methods that would be generated by the Wrapper Wizard.
</P>
<P>
In case you are interested, I came up with the name &ldquo;ghost classes&rdquo; because
they are ephemeral and in a sense invisible.  The word &ldquo;ghost&rdquo; seemed to
express something of those ideas, and had not yet been overtaken by the computing
community's ravening appetite for jargon.
</P>
<P>
Ghost classes do not appear in the standard browsers, since they are not fully
linked into the class hierarchy, and they are not installed in the global
<CODE class="Smalltalk">Smalltalk</CODE> dictionary.
Ghost classes are not written to the change log.
</P>
<P>
The name of a ghost class is the fully qualified name of the corresponding Java class
for the instance side, and the same with '.static' added for the class side.  The name is
only used by instances' <CODE class="Smalltalk">#printString</CODE>, etc. methods.
</P>

<H2>Pros and Cons</H2>
<P>
The great advantage of ghost classes is that they are convenient.  There is no need
to mess about creating wrapper classes by hand (not even with the aid of the Wizard).
They also have a performance edge, though the difference may not be significant for
many applications.
</P>
<!-- UPDATEME -->
<P>
The biggest disadvantage of ghost classes is that loading any Java class will
(subject to configuration) cause a ghost to be generated for it.  But doing that
may well cause other classes to be loaded, and so on.  For instance, in the
Swing <A href="wrapper-example-2.html">example</A>, the first mention of
<CODE class="Java">javax.swing.JFrame</CODE> causes a long pause
as almost 300 Java classes, mostly bits of Swing, are loaded and have ghosts
generated.  This delay only occurs on the first mention of the class, but it is
still annoying and creating a fix for it is very high priority.
<strong>Stop press:</strong> <em>actually a fix is available now, if you use a
<CODE class="Smalltalk">JVMLazyGhostClassMaker</CODE> instead of
an <CODE class="Smalltalk">JVMGhostClassMaker</CODE> &mdash; the
feature is still experimental, though.</em>
</P>
<P>
Ghost classes also take up more memory, naturally.  The impact is not huge, but it may
matter in some cases.  For one example, loading the 300 Swing classes causes
around 6000 ghost methods to be generated; they take up, between them, around 1MB of memory.
It's worth mentioning that the planned improvements to ghost class generation will also
reduce the ghost method footprint &mdash; most of the Swing classes are never used
(by JNIPort), and so would not have ghost methods generated for them.
</P>
<P>
One other aspect of ghost classes might be considered to be a disadvantage.  Ghost methods
are generated as Smalltalk source (rather than by bytecode magic), so they need the compiler.
Dolphin's licence does permit you to distribute the compiler DLL with a deployed application,
but it is something of a nuisance, especially as the compiler is not included in
&ldquo;To-Go&rdquo; applications.
</P>

<H2>Using Ghost Classes</H2>

<P>
Ghost classes are just dynamic special-cases of static
<A href="wrapper-classes.html">wrapper classes</A>, and all the observations about
wrapper classes are true of ghost classes.  In particular they use the same
<A href="method-names.html">naming scheme</A> for generated methods.
</P>
<P>
The big difference, of course, is that you don't have to have generated a static
wrapper to call a Java object's methods.
</P>

<P>
You can use the ghost methods &ldquo;raw&rdquo; or you can set up helper methods.
There are at least two ways of doing this in a reasonably well-structured way.
You can use custom wrapper classes, or you can write a Facade/Adaptor class.
</P>

<P>
Using a custom wrapper class is just the same as writing a custom static wrapper class.
You create a subclass of <CODE class="Smalltalk">JavaInstance</CODE>
or  <CODE class="Smalltalk">JavaStatic</CODE>, give it a class-side
<CODE class="Smalltalk">#javaClassName</CODE> method, and the next time JNIPort is started,
all ghosts that inherit from the corresponding Java class will be given ghost classes that
inherit from your class.  You can now add whatever Smalltalk methods you like to your
class &mdash; it's a bit like being able to extend the Java class with new methods.
</P>
<P>
You can leave it at that; the single method <CODE class="Smalltalk">#javaClassName</CODE> is
enough to tell JNIPort about the connection between your class and the Java class.  However,
you may prefer (as I do) to use the Wrapper Wizard to create and populate the wrapper class.
If you do that then you'll have a complete static wrapper to work from, but at runtime
all the static wrapper methods will be overridden by their more efficient ghost equivalents.
</P>

<P>
Alternatively, you can create an Adaptor or Facade.  For instance the Smalltalk class
<CODE class="Smalltalk">JavaIteratorAdaptor</CODE> (in package 'CU Java Additional Wrappers')
is an Adaptor of Java's <CODE class="Java">java.util.Iterator</CODE> interface to Smalltalk
<CODE class="Smalltalk">ReadStream's</CODE> protocols.  Instances contain a reference to the
ghost proxy for some Java object, and they implement Smalltalk methods like
<CODE class="Smalltalk">#atEnd</CODE> by forwarding to the wrapper methods
<CODE class="Smalltalk">#hasNext_null</CODE> and <CODE class="Smalltalk">#next_null</CODE>,
which are the ghost class equivalents of the methods of 
<CODE class="Java">java.util.Iterator</CODE>.  That means that any Java object that
implements <CODE class="Java">java.util.Iterator</CODE> (as well as any other that happens
to have the same two methods) can be used as a <CODE class="Smalltalk">ReadStream</CODE>
via a <CODE class="Smalltalk">JavaIteratorAdaptor</CODE>.

<H2>Configuration</H2>
<P>
Ghost class generation is controlled by the 'ghostClassSettings' sub-setting.
</P>
<P>
Most of the settings determine what members will be exposed by ghost methods, they are the same
as the corresponding flags that control the defaults for static wrapper generation.
By default JNIPort will only expose &ldquo;public&rdquo; members.
Custom wrapper classes can override the settings, but nothing in this
version of JNIPort uses the feature.
</P>
<P>
The 'retainMethodSource' flag controls whether JNIPort will keep the source to ghost methods.
If it does then the source is stored as Strings in the image, not written to the change log.
This setting is ignored except in development sessions.
</P>
<P>
The remaining options control what kinds of objects JNIPort will generate ghost classes for:
</P>
<UL>
<LI><P>
'useGhostInstances' and 'useGhostClasses' tell JNIPort to create
ghost classes for the instance and class sides of all normal Java classes
(<CODE class="Java">java.lang.Object</CODE> and its subclasses except arrays).
Both of these are on by default; it wouldn't really make a lot of sense to turn them off.
</LI></P>
<LI><P>
'useGhostInstancesForInterfaces' and 'useGhostClassesForInterfaces' tell JNIPort to
create ghost classes for Java's interfaces.  There's quite a big difference between
the class-side and instance-side in this case.  On the class-side, interfaces are like
classes and are represented by normal class statics.  Interfaces quite often have
lists of public constants, so JNIPort generates ghosts for the class-side by default.
Interface &ldquo;instances&rdquo; are JNIPort's built-in way of creating adaptors
for Java objects known to implement some interface (more information is
<A href="java-base.html#Interface Instances">here</A>).  Since ghost classes don't need
adaptors as much as statically-generated wrappers, it's not clear whether this option should
be turned on by default.  In the end I decided not to, for no better reason that to
demonstrate that it could be done.
</LI></P>
<LI><P>
'useGhostInstancesForArrays' and 'useGhostClassesForArrays' tell JNIPort to create
ghost classes for the instance and class sides of the synthetic Java classes
that represent arrays.  Both of these are turned off by default; there's not a
lot of point in turning them on since arrays don't add any extra methods on either
the instance or class side (the <CODE class="Java">length</CODE> field of arrays is
a sham, implemented by the Java compiler, and although Java arrays do implement
<CODE class="Java">java.lang.Cloneable</CODE>, they don't have a genuine public
<CODE class="Java">clone()</CODE> method).  It's rare to use the methods inherited
from <CODE class="Java">java.lang.Object</CODE>, but if you are doing this a lot, and
need the extra performance (unlikely) then you could turn on 'useGhostInstancesForArrays'.
</LI></P>
</UL>

<H2>How they work</H2>
<P>
<strong>Please note:</strong> this description has become slightly out of date.  It is still
accurate, but it should be updated to discuss the new lazy ghosts too
</P>
<P>
When JNIPort creates a class static for a Java class that it hasn't seen before (see
the <A href="players.html#Class Static Lifecycle">class lifecycle</A>), the
<CODE class="Smalltalk">GhostClassMaker</CODE> is told about it.  It uses the 'ghostClassSettings'
to decide whether to generate a class-side ghost class or an instance-side ghost class, or
both.  If either is called for, then it generates the class(es) and populates them with
ghost methods. (By the way, the code for doing this actually lives in
<CODE class="Smalltalk">JavaClassStatic</CODE>, but that is just an implementation detail,
the <EM>responsibility</EM> rests with the ghost maker.)
</P>
<P>
If the Java class has a superclass (interfaces do not, and neither does
<CODE class="Java">java.lang.Object</CODE>), then it finds the instance class and class static
class used for the superclass.  For instance when it generates ghost classes for
<CODE class="Java">java.util.Hashtable</CODE> it starts with the instance and class static classes
used for <CODE class="Java">java.util.Dictionary</CODE>.  If the Java class does not have
a superclass then it starts with either 
<CODE class="Smalltalk">JavaClassInstance</CODE> or
<CODE class="Smalltalk">JavaInterfaceInstance</CODE>
for the instance class, and either
<CODE class="Smalltalk">JavaClassStatic</CODE>
or <CODE class="Smalltalk">JavaInterfaceStatic</CODE>
for the class static class. (I'm ignoring array classes, which have further specialisations.)
It then creates ghost subclass(es) of them.  A ghost subclass is just an ordinary class that
has not been added to the Smalltalk namespace, nor to its superclass's list of subclasses.
(They also answer true to <CODE class="Smalltalk">#isGhostClass</CODE>, and instances answer
true to <CODE class="Smalltalk">#isGhost</CODE>.)
</P>
<P>
After creating the appropriate class(es), the ghost maker populates them with
ghost methods.  It adds the same set of methods as a similarly configured
Wrapper Wizard would, but the implementations of those methods is not the
same (more on this below).
</P>
<P>
In normal circumstances the ghost methods expose (a subset of) the members of the Java
class.  However there is one situation where ghost methods are generated for inherited
members too.  This happens when the ghost maker is subclassing a non-ghost wrapper class.
For instance, after <A href="players.html#Bootstrapping">bootstrapping</A> but before any
static wrapper classes have been converted into ghosts, the class registry is (temporarily)
set up so that instances of <CODE class="Java">java.lang.String</CODE> would be wrapped
by instances of the (non-ghost) class <CODE class="Smalltalk">JavaLangString</CODE>.
The ghost maker creates a ghost subclass of <CODE class="Smalltalk">JavaLangString</CODE>
and registers that as the preferred wrapper class for <CODE class="Java">java.lang.String</CODE>.
This is necessary to ensure that any extra methods that have been added to
<CODE class="Smalltalk">JavaLangString</CODE> will be inherited by the new ghost class.
However, although  <CODE class="Smalltalk">JavaLangString</CODE> is a subclass of
<CODE class="Smalltalk">JavaLangObject</CODE>, it is <EM>not</EM> a subclass of the
new ghost class for <CODE class="Java">java.lang.Object</CODE>.  Therefore the ghost maker
must generate ghost methods exposing the members inherited from 
<CODE class="Java">java.lang.Object</CODE> as well as those that are specific to
<CODE class="Java">java.lang.String</CODE>.
</P>
<P>
There is one other special case, constructors.  In Java, constructors are not inherited
(not even in the sense that static methods can be considered to be &ldquo;inherited&rdquo;).
For statically-generated wrappers that doesn't matter because attempting to use an
inherited wrapper for a constructor will cause a run-time error when the dynamic lookup
of the &ldquo;inherited&rdquo; constructor fails (or at least it should do,
I have noticed that the BEA JRockit runtime gets this wrong).  For ghost methods, the
lookup is performed as the ghost method is created and the result is bound into the method.
That means that if the constructor wrapper were inherited, then when it was called from
a subclass, it would be calling the superclass's constructor, rather than creating an
instance of the subclass.  The way that the ghost maker avoids this problems is to
ensure that all inherited constructors are overridden to call
<CODE class="Smalltalk">self shouldNotImplement</CODE>.
(This behaviour can be configured for statically-generated wrapper classes too; it is
controlled by the 'generateSNIContructors' option of the 'wrapperGeneratorSettings.)
</P>

<H2>Ghost Methods</H2>
<P>
Ghost methods are created by the ghost maker to expose the underlying Java object's (or class's)
methods and fields.  They are created by compiling generated Smalltalk code.  Normally the code
is discarded immediately unless the 'retainMethodSource' is set and you are in a development
session.  The generated code is highly stereotyped, so the corresponding bytecodes tend to
repeat often; ghost methods share their bytecode arrays wherever possible (in my current image,
there are 14K ghost methods, but they only use 252 distinct bytecode arrays).
</P>
<P>
Because the Smalltalk code is automatically generated, and isn't intended for people
to read or modify, the ghost maker can take several performance-enhancing shortcuts.  The
generated code does not resemble that generated by the Wrapper Wizard.
</P>
<P>
One optimisation is that ghost methods use the lowest levels of JNIPort directly, rather
that going through the framework provided by level 2 ('Java Base') of JNIPort.
</P>
<P>
A second optimisation is that JNIPort can make use of information available when the method
is generated, to write code that otherwise would require a run-time lookup each time the method
was called.  One application of this is that the JNI &ldquo;method ID&rdquo; can be resolved
at this time and hard-wired in the code (see below).  The other is that, in some cases, the
method can be determined to return a Java object of a &ldquo;final&rdquo; class, for instance
<CODE class="Java">java.lang.String</CODE>.  When JNIPort creates a wrapper object for a
JNI reference, it needs to find the class static corresponding to the exact class of the Java
object, which will then act as a factory for creating a proxy of the required type.  If the
exact class is known in advance, then JNIPort can generate code that directly asks the
class static to create the proxy, rather than asking the JVM object to find it at runtime.
</P>
<P>
The third optimisation is that JNIPort can embed references to the significant objects
directly in the method's literal frame.  The effect is similar to using Dolphin's
<CODE class="Smalltalk">##(...code...)</CODE> syntax, although the details are different.
The way it is implemented is that the generated Smalltalk code uses Symbol literals
to stand for the object references that are to be hard-wired.  After the code has been compiled,
a second pass finds the Symbols in the compiled method's literal frame and replaces them
with references to the intended objects.  Currently, JNIPort hardwires references to:
</P>
<UL>
<LI>The JVM object.</LI>
<LI>The JNI Method ID or Field ID.</LI>
<LI>The class static that will be asked to generate a wrapper object for the result.</LI>
</UL>
<P>
If you have the 'retainMethodSource' option turned on, then you will see the Symbols
if you step into a ghost method in the debugger.  Please note: you cannot recompile the
source of a ghost method and still expect it to work! (Which means that you can't set
breakpoints in ghost methods.)
</P>
<P>
The effects of these optimisations are that, compared to statically generated wrapper
methods:
</P>
<UL>
<LI><P>
Measured by calling <CODE class="Java">java.lang.String.length()</CODE> (which simply
accesses a field in the String object), the minimum overhead of calling a Java method drops
from 18.5 microseconds to 6.6 microseconds.  For comparison, around 3.2 microseconds
of that time is spent in JNI itself, and around 0.7 microseconds in Dolphin's external
call mechanism.  The real execution of <CODE class="Java">length()</CODE> is hardly measurable
&mdash; roughly a nanosecond.
</P></LI>
<LI><P>
If the optimisation for predetermining the wrapper factory is applicable, then the
time taken to create the proxy is approximately halved, to around 50 microseconds.
</P></LI>
</UL>
<P>
(All times measured on a Pentium3 laptop running at 650Mhz, using Sun's J2SDK&nbsp;1.4.1
and Dolphin&nbsp;5.0.3)
</P>

<!--	real-text-ends-here	-->
</TD>
</TR>
</TBODY>
</TABLE>
<HR>
<P><SMALL>Copyright &copy; Chris Uppal, 2003-2005</SMALL></P>
<P><SMALL>
Java, JNI (probably), JVM (possibly), and God knows what else, are trademarks of
Sun Microsystems, Inc.
</SMALL></P>
</BODY>